# 性能优化

## 1.内存管理
* 内存：由可读写单元组成，表示一片可操作空间
* 管理：人为的去操作一片空间的申请、使用和释放
* 内存管理：开发者主动申请空间、使用空间、释放空间
* 管理流程：申请——使用——释放
```
// 申请
let obj = {};
// 使用
obj.name = 'lin;
// 释放
obj = null;
```

## 2.垃圾回收
* JavaScript中的垃圾
    * JavaScript中的内存管理是自动的
    * 对象不再被引用时是垃圾
    * 对象不能从根上访问到时是垃圾

* JavaScript中可达对象
    * 可以访问到的对象就是可达对象（引用、作用域链）
    * 可达的标准就是从根本出发是否能够被找到
    * JavaScript中的根就可以理解为全局变量对象   

* GC 就是垃圾回收机制的简写
    * GC 可以找到内存中的垃圾、并释放和回收空间
    * GC 里的垃圾
        * 程序中不再需要使用的对象
    * GC 算法
        * 垃圾回收器工作时查找和回收所遵循的规则
        * 常见 GC 算法
            * 引用计数
            * 标记清除
            * 标记整理
            * 分代回收

### 引用计数器算法
* 核心思想：设置引用数，判断当前引用数是否为0
* 引用关系改变时修改引用数字
* 引用数字为0时立即回收
* 优点：
    * 发现垃圾时立即回收
    * 最大限度减少程序暂停
* 缺点：
    * 无法回收循环引用的对象
    * 资源消耗大、时间开销大

### 标记清除算法
* 核心思想：分标记和清除两个阶段完成
* 遍历所有对象找标记活动对象
* 遍历所有对象清除没有标记对象
* 回收相应空间
* 优点：
    *  相对引用计数来说，可以去解决循环引用不能回收的问题
* 缺点：
    * 它会产生一个空间碎片化的问题，不能让空间得到最大化的使用
    * 不会立即回收垃圾对象

### 标记整理算法
* 标记整理可以看做是标记清除的增强
* 标记阶段的操作和标记清除一致
* 清除阶段会先执行整理，移动对象位置    
* 优点：
    * 减少碎片化空间
* 缺点：
    * 不会立即回收垃圾对象

## 3.V8
* V8 是一款主流的JavaScript执行引擎
    * 采用即时编译
    * 内存设限：64位（1.5G）、32位（800M）
* V8采用基于分代回收思想实现垃圾回收    
* V8中常见的GC算法    
    * 分代回收
    * 空间复制
    * 标记清除
    * 标记整理
    * 标记增量

### V8内存分配
* V8 内存空间一分为二，左边为新生代、右边为老生代
* 小空间用于存储新生代对象，64位（32M）、32位（16M）
* 新生代指的是存活时间较短的对象

### 新生代对象回收
* 回收过程采用复制算法 + 标记整理
* 新生代内存区分为两个等大小空间
* 使用空间为from，空闲空间为to
* 活动对象存储于from空间
* 标记整理后将活动对象拷贝至to
* from与to交换空间完成释放
* 注：回收细节说明
    * 拷贝过程中可能出现晋升
    * 晋升就是讲新生代对象移动至老生代
    * 一轮GC还存活的新生代需要晋升
    * to空间的使用率不能超过25%

### 老生代对象回收
* 老年代对象存放在右侧老生代区域
* 64位（1.4G）、32位（700M）    
* 老年代对象就是指存活时间较长的对象
* 回收实现：
    * 主要采用标记清除、标记整理、增量标记算法
    * 首先使用标记清除完成垃圾空间的回收
    * 采用标记整理进行空间优化
    * 采用增量标记进行效率优化

### 新生代和老生代对比
* 新生代区域垃圾回收使用空间换时间
* 老生代区域垃圾回收不适合复制算法    

## 4.内存问题的外在表现
* 页面出现延迟加载或经常性暂停
* 页面持续性出现糟糕的性能
* 页面的性能随时间延长越来越差

## 5.界定内存问题的标准
* 内存泄漏：内存使用持续升高
* 内存膨胀：在多数设备上都存在性能问题
* 频繁垃圾回收：通过内存变化图进行分析

## 6.监控内存的几种方法
* 浏览器任务管理器
* Timeline 时序图记录
* 堆快照查找分离 DOM
* 判断是否存在频繁的垃圾回收

### 浏览器任务管理器
* shift + ESC 打开

## 7.判断是否存在频繁的GC
* Timeline 中频繁是上升下降
* 任务管理器中数据频繁增加减小

## 8.为什么要慎用全局变量
* 全局变量定义在全局执行上下文，是所有作用域链的顶端
* 全局执行上下文一直存在于上下文执行栈，直到程序退出
* 如果某个局部作用域出现了同名变量这回遮蔽或者污染全局

## 9.代码优化
* 慎用全局变量
* 缓存全局变量
* 通过原型对象添加附加方法
* 避开闭包陷阱
* 避免属性访问方法使用
* for循环优化
```
let arr = [1,2,3,4,5,6,7,8,9];
for(let i = arr.length; i; i--){
    console.log(arr[i]);
}
```
* 选择最优的循环方法
    * foreach > for > for-in
* 优化节点添加 
    * （采用文档碎片）
    ```
    const fragEle = document.createDocumentFragment();
    for(let i = 0; i < 10; i++){
        let oP = document.createElement('p');
        oP.innerHTML = i;
        fragEle.appendChild(oP);
    }
    document.body.appendChild(fragEle);
    ```

    * （采用克隆）
    ```
    <p id="p_centent"></p>

    let odlP = document.getElementById('p_centent');
    for(let i = 0; i < 10; i++){
        let newP = odlP.cloneNode(false);
        oP.innerHTML = i;
        document.body.appendChild(newP);
    }
    
    ```
* 字面量代替new    